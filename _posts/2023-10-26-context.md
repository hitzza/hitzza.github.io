---
layout: single
title: "[자바스크립트] 컨텍스트 API를 사용하여 전역으로 로그인 정보를 관리해 보자(작성 중)"
---

# 컨텍스트 API를 사용하여 전역으로 로그인 정보를 관리해 보자

## 컨텍스트 API란?

React에서는 상위 컴포넌트에서 하위 컴포넌트로 값을 전달하기 위해 props를 사용해야 하는데, props를 사용하지 않아도 값을 공유할 수 있게 만들어 주는 기능이 컨텍스트 API이다. 주로 전역 상태를 관리할 때 사용한다.

## 사용법

전역적으로 상태를 관리할 때 주로 App 파일에서 컨텍스트의 Provider를 설정해 준다.

```js
import React, { createContext } from "react";

const Context = createContext("context");

function App() {
  return (
    <Context.Provider value="Hello World!">
      <Component />
    </Context.Provider>
  );
}

export default App;
```

## App 파일보다 상위 파일인 index에서 적용하기

현재 진행 중인 프로젝트에서 로그인 정보를 Redux를 사용해 전역 상태로 관리했는데 리팩토링 과정에서 Redux를 제거하고 Context API로 변경하기로 결정이 났다. 하지만 이미 App 파일에는 로그인 정보와 상관없는 컨텍스트가 있었고, 전역적인 정보를 가지고 있는다는 걸 시맨틱 적으로 표현하고 싶어 App보다 상위인 index 파일에서 적용하고 싶었다.
하지만 리액트에서는 값이 변경된 걸 인지하려면 state를 변경해야 하는데 훅을 사용하기 위해선 함수 내부에서 훅을 사용해야 한다. App파일은 함수이기 때문에 이전에는 문제가 되지 않았지만 index 파일에서는 상황이 달라진다.

```js
//index
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

const root = ReactDOM.createRoot(
  document.getElementById("root") as HTMLElement
);
root.render(<App />);
```

index는 함수가 아니기 때문에 훅을 사용할 수 없는 이슈가 생겼다.
그래서 선택한 방법이 함수를 만들어서 컨텍스트 Provider를 리턴 해주는 방식으로 결정했다.
로그인 정보 + 로그인한 유저 정보를 담을 컨텍스트라 UserInfoProvider.tsx 라는 이름으로 작성할 것이다.

UserInfoProvider.tsx

```js
import { useReducer } from "react";
import { INITUSERINFO } from "../constant/UserInfoInitialState";
import reducer from "./Reducer";
import { 컨텍스트, 컨텍스트_디스패치 } from "./UserInfoContext";

const UserInfoProvider = ({ children }: { children: React.ReactNode }) => {
  const [state, dispatch] = useReducer(reducer, INITUSERINFO);

  return (
    <컨텍스트.Provider value={state}>
      <컨텍스트_디스패치.Provider value={dispatch}>
        {children}
      </컨텍스트_디스패치.Provider>
    </컨텍스트.Provider>
  );
};

export default UserInfoProvider;
```

순서대로 코드를 설명하자면

state 관리는 단순히 useState를 사용해서 토큰값을 저장해도 되지만 향후 전역적으로 다른 정보까지 저장할 가능성도 있고, 유저의 정보까지 저장할 것이기 때문에 useReducer를 사용하였다.
그리고 초깃값(토큰+유저 정보)을 따로 INITUSERINFO는 이름으로 파일로 분리하였고

UserInfoInitialState.ts

```js
export const INITUSERINFO = {
  accessToken: "",
  checkIsSignIn: false,
  id: 0,
  image: "",
  introduction: "",
  nickName: "",
};
```

나머지는 useReducer사용하기 위한 코드이다.
UserInfoProvider는 2개의 Provider를 사용하는데 컨텍스트는 값을 저장하는 컨텍스트로 사용할 것이고, 컨텍스트\_디스패치는 값을 업데이트하는 컨텍스트로 분리해서 코드를 작성할 것이다.

컨텍스트를 작성하기에 앞서 나는 타입스크립트를 사용하였기 때문에 컨텍스트에서 사용할 타입을 먼저 지정해 주어야 한다.

타입은 바로 생성해서 사용하는거도 가능하지만 현재 프로젝트에서는 중복사용되는 부분이 많아 contextUserInfo.ts 파일을 만들어서 타입파일을 모아놓는 폴더에 생성해 주었다.

```js
//유저 정보
export type userInfo = {
  accessToken: string,
  checkIsSignIn: boolean,
  id: number,
  image: string,
  introduction: string,
  nickName: string,
};
//리듀서
export type actionType =
  | { type: "AUTH", accessToken: string }
  | {
      type: "SET_USERINFO",
      id: number,
      image: string,
      introduction: string,
      nickName: string,
    };
```

이제 본격적으로 컨텍스트를 만들어 보자.

파일 이름은 UserInfoContext.ts로 컨텍스트들이 모여있는 폴더를 생성하여 저장해주었다.

```js
import React, { createContext } from "react";
import { actionType, userInfo } from "../types/contextUserInfo";

type userInfoDispatch = React.Dispatch<actionType>;

export const userInfoStateContext =
  (createContext < userInfo) | (undefined > undefined);
export const userInfoDispatchContext =
  (createContext < userInfoDispatch) | (undefined > undefined);
```

코드부터 설명하자면 컨텍스트를 사용하기 위해 리액트의 createContext와 직전에 작성한 타입 파일들을 임포트 해주었다.
그리고 값을 불러오기 위한 컨텍스트인 userInfoStateContext, 값을 업데이트하기 위한 userInfoDispatchContext를 따로 분리하여 작성하였는데
