---
layout : single
title : '[자바스크립트]호이스팅이란'
---
호이스팅(Hoisting)이란
===
JavaScript에서 호이스팅(hoisting)이란, 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것입니다. 변수와 함수(선언식)의 선언과 할당을 분리한 후, 선언 부분만 항상 컨텍스트 내의 최상단으로 끌어 올리는 것을 의미합니다.   
   
    

호이스팅의 대상
===
* 호이스팅 현상은 var를 사용한 변수 선언문과 함수의 선언식에서만 일어납니다.   
* var를 제외한 let, const로 변수를 선언하거나, 함수 표현식에서는 호이스팅 현상이 일어나지 않습니다.    
- 함수의 표현식과 선언식   
   
```js
function a(){//함수 표현식
    console.log('함수의 표현식');
}

var b = function(){//햠수 선언식
    console.log('함수의 선언식');
}
```
   
- 간단하게 정리하자면 일반적인 방식은 function을 사용하여 선언한 함수를 표현식
- var b = function(){}처럼 함수를 변수에 할당한 방식을 선언식이라고 합니다.
   

   
함수와 변수의 호이스팅
===
   
함수와 변수의 호이스팅이 어떤 방식으로 일어나는지 코드로 설명하면 간단하니 밑의 예제를 보겠습니다.
---

+ 변수의 호이스팅(var, let, const)   
    
```js
let a = 1;
var b = 2;
const c = 3;
```
해당 코드를 실행하게 되면, 밑의 순서로 선언과 할당이 이루어집니다.
   
```js
var b;//1.변수 선언 부부만 최상단으로 끌어 올려지고,b에 undefined를 할당 받습니다.
let a = 1;//2.let으로 선언한 변수에는 호이스팅이 일어나지 않습니다.
b = 2;//3.처음 var로 선언한 b의 위치에서 b의 값에 2를 할당 받습니다.
const c =3;//4.const로 선언한 변수에도 마찬가지로 호이스팅이 일어나지 않습니다.
```
호이스팅이 일어나서 해당 컨텍스트의 최상단에 변수의 선언이 이루어집니다. 호이스팅은 변수의 선언 부분만 상단에 위치하게 되어, 값은 undefined가 할당되고 처음 var로 선언한 위치에서 값을 할당받게 됩니다.

+ 함수의 호이스팅

```js
function a(){ 
    console.log('함수 표현식');
}
var b = function(){ 
    console.log('함수 선언식');
}

```
해당 코드를 실행하게 되면, 밑의 순서로 선언과 할당이 이루어집니다.

```js
var a = function a(){ }//1.함수 호이스팅
var b;//2.변수 호아스팅, undefined할당
b = function(){ }//3.변수값 할당
```
함수도 변수와 마찬가지로 호이스팅이 일어나서 선언 부분과 표현식의 선언만 해당 컨텍스트의 최상단에 끌어올려지게 됩니다. (함수 내부의 코드를 실행 하는 건 예) a(); 로 함수를 호출했을 때 이루어집니다.)
   


+ 변수와 함수의 호이스팅
   
var와 함수 표현식의 호이스팅 우선순위는 없으며, 먼저 작성한 코드 순서대로 실행됩니다.   
예)
```js
let a = 1;
function b() {
    var c;
    function c() { }
    console.log(c);
    c = 'C';
    console.log(c);
}
b();
```
해당 코드에 호이스팅이 일어나서 실행되는 순서를 코드로 표현하자면
   

```js
var b = function b(){//1.함수 선언부분 호이스팅
    //함수가 호출되어야 함수 내부 코드 실행
    var c; //4.함수 내부 변수 호이스팅, undefined
    var c = function() { }//5. 함수 내부 함수 호이스팅
    console.log(c); //6. [Function: c]
    c = 'C';//7. 변수c에 C 재할당
    console.log(c);//8. C
}
let a = 1;//2.let은 호이스팅이 일어나지 않음
b();//3.b함수 호출
```
위 코드를 정리하자면
   
1. 메모리 공간을 확보하고, 확보된 공간의 주솟값을 변수 b에 연결합니다.
2. 변수 a를 선언하고, 값1을 할당합니다.
3. 함수 b를 다른 메모리 공간에 저장하고, 그 주소값을 변수 b에 할당합니다
4. b 함수를 호출하고, 호출 후 함수 내부의 코드를 실행합니다.
5. 호이스팅이 순서대로 일어나 변수 c를 선언합니다. (위 코드의 4번 순서, 값 : undefined)
6. c라는 이름의 변수가 이미 있으므로 함수 c를 해당 변수에 할당합니다. (5번)
7. 변수 c에 'C'를 재할당합니다. 
   
   
   
함수 선언문과 호이스팅의 위험성
===
함수 선언문의 호이스팅 현상 때문에 자바스크립트 초보자분들에게는 다소 혼란스러울 수 있는 개념입니다. 코드를 제대로 작성했음에도 불구하고 에러가 난다거나, 원하는 결과물이 나오지 않을 수도 있습니다.
코드로 예를 들어보겠습니다.

```js
var a = 1;
var b = 2;

sumNum();

var sumNum = function(){
    console.log(a+b);
}
```
해당 코드 결과물로 TypeError: sumNum is not a function가 출력되는데
호이스팅 현상에 의해 sunNum함수를 호출했을 때 sumNum은 undefined이기 때문에 TypeError가 발생했습니다.
지금처럼 에러가 발생할 경우도 있지만, 코드가 매우 긴 파일에서 중간에 문제가 생긴다면 상황이 더욱 문제가 커질 수 있습니다.
```js
function sum(x,y){
    return x+y;
}
var a = sum(1,2);
console.log(a);

var sum = function(x,y){
    return x + '+' + y + '=' + (x+y);
}

var c = sum(1,2);

console.log(c);
```
원활한 작업 진행을 위해서 전역 공간에 동명의 함수를 중복으로 선언하는 일은 없어야 하지만 극단적인 예로 상단의 코드가 1000줄이 넘는 매우 긴 코드의 중간에 작성된 상태로 커밋과 머지를 했다고 가정했을 때, 사용자가 함수 표현식으로 선언한 결괏값을 의도하고 sum 함수를 실행하지만, 결과값으로 문자열이 포함된 값을 받습니다. 하지만, 잘못된 값을 전달받았음에도 불구하고 자바스크립트의 암묵적 형변환에 의해 에러가 없이 의도하지 않은 값이 출력된다면 어떤 코드가 문제인지 어디서부터 어떻게 찾아야 할지 엄두도 나지 않습니다.
   
호이스팅에 대해 알아보고 있으면 코드가 복잡하게만 느껴지고 단점이 크게 느껴집니다.
그런데 왜 호이스팅에 대해 알아야 할까요?
코드의 가독성과 유지보수를 위해서는 호이스팅이 일어나지 않도록 코드를 작성하는게 좋지만, ES6 이전에 사용하던 코드에서는 아직 호이스팅이 일어나는 코드가 많고 아직까지 해당 코드를 사용하고 있는 경우가 있기 때문에 아직까지는 호이스팅에 대해 이해하고 있어야 합니다.

참조
===
+ [MDN](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)   
+ 코어 자바스크립트