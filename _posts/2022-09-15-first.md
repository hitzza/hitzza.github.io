---
layout: single
title: "[자바스크립트]호이스팅이란"
---

# 호이스팅(Hoisting)이란

JavaScript에서 호이스팅(hoisting)이란, 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것입니다. '끌어 올리다'라는 hoist와 -ing가 합쳐진 동명사로 변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념입니다. 자바스크립트 엔진이 실제로 끌어 올리지는 않지만 끌어올린 것으로 간주하자는 것이죠.

# 호이스팅의 대상

- 보통 생각하는 상단으로 끌어 올려지는 호이스팅 현상은 var를 사용한 변수 선언문과 함수의 선언식에서 일어납니다.
- var를 제외한 let, const로 변수를 선언하거나, 함수 표현식에서도 호이스팅 현상이 일어나지만 앞서 말했던 것처럼 끌어올려진다는 느낌은 들지 않습니다. 해당 부분에 대해서는 포스트 하단에서 다루겠습니다.

* 함수의 표현식과 선언식

```js
function a() {
  console.log("함수의 선언식");
}
//a()처럼 함수 리터럴로 생성한 함수를 함수의 선언식이라 합니다.

var b = function () {
  console.log("함수의 표현식");
};
//b()처럼 함수 리터럴로 생성한 함수를 변수에 할당하는 방법을 함수의 표현식이라 합니다.
```

# 함수와 변수의 호이스팅 현상

## 함수와 변수의 호이스팅이 어떤 방식으로 일어나는지 코드로 설명하면 간단하니 밑의 예제를 보겠습니다.

- 변수의 호이스팅(var, let, const)

```js
let a = 1;
var b = 2;
const c = 3;
```

해당 코드를 실행하게 되면, 밑의 순서로 선언과 할당이 이루어집니다.

```js
var b; //1.
let a = 1; //2.
b = 2; //3.
const c = 3; //4.
```

- 결론부터 말씀드리자면 var, let, const를 사용한 변수선언 모두에서 호이스팅이 일어납니다. 하지만 해당 컨텍스트 최상단으로 끌어올려지는 것처럼 보이는 호이스팅 현상이 var를 사용해 선언한 변수에서만 일어납니다.

1. var를 사용해 선언한 변수는 호이스팅 현상으로 인해 선언부가 최상단으로 끌어올려지고, b라는 이름의 메모리 공간을 확보한 다음 undefined를 할당 받습니다.
2. a라는 이름의 메모리 공간을 확보한 다음 1을 할당 받습니다.
3. 처음 var로 선언한 b의 위치에서 b의 값에 2를 할당 받습니다.
4. c라는 이름의 메모리 공간을 확보한 다음 3을 할당 받습니다.

해당 포스트에서 호이스팅이 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것이라고 설명해 드렸습니다. var, let, const 모두 순서의 차이가 있을 뿐 해당 변수 이름의 메모리 공간을 할당받고 값을 할당받았습니다. var를 사용한 변수는 해당 컨텍스트 최상단에 끌어올려진 것처럼 선언이 이루어진 것뿐 호이스팅은 세 가지 변수 모두 일어났습니다.

하지만 이상한 점이 있습니다. 모두 호이스팅이 일어났는데 왜 변수마다 다른 현상이 일어나는 것일까요?
그 이유는 변수의 선언 방식과 TDZ(Temporal Dead Zone)때문입니다.

변수의 선언

---

자바스크립트에서 변수의 선언은 var, let, const 같은 변수 선언 키워드로 변수 이름을 선언하면, 내부적으로 메모리 공간을 확보한 후 변수 이름과 확보된 메모리 공간의 주소를 연결합니다.
그리고 선언 -> 초기화 2단계에 걸쳐 변수 선언을 수행합니다.

- 선언 단계 : 변수 이름을 실행 컨텍스트에 등록해서 자바스크립트 엔진에 변수의 존재를 알립니다.
- 초기화 단계 : 값을 지정하기 위한 메모리 공간을 확보하고, 암묵적으로 undefined를 할당해 초기화 합니다.

<!--
변수 선언은 코드가 한 줄씩 순차적으로 실행되기 이전에, 소스코드의 평가 과정에서 완료됩니다.
- 소스코드의 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함해 모든 선언문을 찾아내 먼저 실행한다
- 소스코드의 평가 과정이 끝나면, 비로소 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.
- 이렇게 변수 선언문이 코드의 선두로 마치 끌어올려진 것처럼 동작하는것을 변수 호이스팅이라 한다.
-->

- var를 이용한 선언

```js
console.log(a); //undefined
var a = "var";
console.log(a); //var
```

var는 값을 할당 하거나 재선언 할 수 있고, 선언 단계와 초기화 단계가 동시에 진행되며 변수에 암묵적으로 undefined를 할당해 초기화 합니다.
var선언 이전에 undefined가 할당되어 있는 이유는 변수 선언이 런타임에서 되는 것이 아니라, 그 이전 단계에서 먼저 실행되기 때문입니다. 자바 스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서, 변수 선언을 포함한 모든 선언문을 찾아내 먼저 실행합니다. 변수 선언이 어디에 있든 상관없이 다른 코드들 보다 먼저 실행되는 현상이 호이스팅에 인해 일어나는 것입니다.

- let을 이용한 선언

```js
console.log(b); //ReferenceError
let b = "let";
console.log(b); //let
```

let은 값을 재할당 할 수는 있지만 변수를 재 선언 할 수 없고, var와 다르게 선언 단계와 초기화 단계가 분리되어 진행됩니다. 실행 컨텍스트의 변수 객체(실행 컨텍스트 렉시컬 환경의 환경 레코드)에 변수 이름을 등록했지만, 메모리에 값이 할당되지 않아 접근할 수 없기 때문에 ReferenceError가 생기는 것입니다.
즉, 호이스팅이 되지 않은 것이 아니라, 호이스팅은 되었으나 메모리에 값이 할당되지 않아 접근할 수 없는 것입니다. 이러한 상태를 일시적 사각지대(Temporal Dead Zone)라고 합니다.
이러한 현상이 생긴 이유는 let은 변수 이름으로 식별자를 해결할 때 변수에 값이 있으면 변수로서 인식하고 변수에 값이 없으면 변수로서 인식하지 않는 특징이 있습니다.
let 변수 선언을 실행하면 그때 값이 설정되며, 값이 있으면 해당 값을 없다면 undefined를 메모리에 값을 할당하기 때문에 변수로서 인식이 가능해 지게 되는 것입니다.

- const를 이용한 선언

```js
const c; ///Syntax error

const d = 'const';
```

const는 값을 재할당과 재선언을 할 수 없고 선언 단계, 초기화 단계 한 번에 진행됩니다. 그리고 선언과 동시에 값이 할당 되어야 하기 때문에 var와 let과 다르게 변수 키워드와 식별자만 이용해서 선언할 수 없습니다. 그러므로 변수 키워드와 식별자만 이용해서 선언 하려고 하면 문법 에러인 Syntax error가 나고, 호이스팅에 의해 끌어 올려지는 것처럼 보이는 현상도 일어나지 않는 것입니다.

<!--
+ 함수의 호이스팅

```js
function a(){
    console.log('함수 선언식');
}
var b = function(){
    console.log('함수 표현식');
}

```
해당 코드를 실행하게 되면, 밑의 순서로 선언과 할당이 이루어집니다.

```js
var a = function a(){ }//1.함수 호이스팅
var b;//2.변수 호아스팅, undefined할당
b = function(){ }//3.변수값 할당
```
함수도 변수와 마찬가지로 호이스팅이 일어나서 선언 부분과 표현식의 선언만 해당 컨텍스트의 최상단에 끌어올려지게 됩니다. (함수 내부의 코드를 실행 하는 건 예) a(); 로 함수를 호출했을 때 이루어집니다.)



+ 변수와 함수의 호이스팅

var와 함수 표현식의 호이스팅 우선순위는 없으며, 먼저 작성한 코드 순서대로 실행됩니다.
예)
```js
let a = 1;
function b() {
    var c;
    function c() { }
    console.log(c);
    c = 'C';
    console.log(c);
}
b();
```
해당 코드에 호이스팅이 일어나서 실행되는 순서를 코드로 표현하자면


```js
var b = function b(){//1.함수 선언부분 호이스팅
    //함수가 호출되어야 함수 내부 코드 실행
    var c; //4.함수 내부 변수 호이스팅, undefined
    var c = function() { }//5. 함수 내부 함수 호이스팅
    console.log(c); //6. [Function: c]
    c = 'C';//7. 변수c에 C 재할당
    console.log(c);//8. C
}
let a = 1;//2.let은 호이스팅이 일어나지 않음
b();//3.b함수 호출
```
위 코드를 정리하자면

1. 메모리 공간을 확보하고, 확보된 공간의 주솟값을 변수 b에 연결합니다.
2. 변수 a를 선언하고, 값1을 할당합니다.
3. 함수 b를 다른 메모리 공간에 저장하고, 그 주소값을 변수 b에 할당합니다
4. b 함수를 호출하고, 호출 후 함수 내부의 코드를 실행합니다.
5. 호이스팅이 순서대로 일어나 변수 c를 선언합니다. (위 코드의 4번 순서, 값 : undefined)
6. c라는 이름의 변수가 이미 있으므로 함수 c를 해당 변수에 할당합니다. (5번)
7. 변수 c에 'C'를 재할당합니다.



함수 선언문과 호이스팅의 위험성
===
함수 선언문의 호이스팅 현상 때문에 자바스크립트 초보자분들에게는 다소 혼란스러울 수 있는 개념입니다. 코드를 제대로 작성했음에도 불구하고 에러가 난다거나, 원하는 결과물이 나오지 않을 수도 있습니다.
코드로 예를 들어보겠습니다.

```js
var a = 1;
var b = 2;

sumNum();

var sumNum = function(){
    console.log(a+b);
}
```
해당 코드 결과물로 TypeError: sumNum is not a function가 출력되는데
호이스팅 현상에 의해 sunNum함수를 호출했을 때 sumNum은 undefined이기 때문에 TypeError가 발생했습니다.
지금처럼 에러가 발생할 경우도 있지만, 코드가 매우 긴 파일에서 중간에 문제가 생긴다면 상황이 더욱 문제가 커질 수 있습니다.
```js
function sum(x,y){
    return x+y;
}
var a = sum(1,2);
console.log(a);

var sum = function(x,y){
    return x + '+' + y + '=' + (x+y);
}

var c = sum(1,2);

console.log(c);
```
원활한 작업 진행을 위해서 전역 공간에 동명의 함수를 중복으로 선언하는 일은 없어야 하지만 극단적인 예로 상단의 코드가 1000줄이 넘는 매우 긴 코드의 중간에 작성된 상태로 커밋과 머지를 했다고 가정했을 때, 사용자가 함수 표현식으로 선언한 결괏값을 의도하고 sum 함수를 실행하지만, 결과값으로 문자열이 포함된 값을 받습니다. 하지만, 잘못된 값을 전달받았음에도 불구하고 자바스크립트의 암묵적 형변환에 의해 에러가 없이 의도하지 않은 값이 출력된다면 어떤 코드가 문제인지 어디서부터 어떻게 찾아야 할지 엄두도 나지 않습니다.

호이스팅에 대해 알아보고 있으면 코드가 복잡하게만 느껴지고 단점이 크게 느껴집니다.
그런데 왜 호이스팅에 대해 알아야 할까요?
코드의 가독성과 유지보수를 위해서는 호이스팅이 일어나지 않도록 코드를 작성하는게 좋지만, ES6 이전에 사용하던 코드에서는 아직 호이스팅이 일어나는 코드가 많고 아직까지 해당 코드를 사용하고 있는 경우가 있기 때문에 아직까지는 호이스팅에 대해 이해하고 있어야 합니다.
-->

# 참조

- [MDN](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)
- 코어 자바스크립트
